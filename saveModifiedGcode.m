function obj = saveModifiedGcode(obj,varargin)
%%  依赖关系判断
if obj.syset.flags.flag_adjusted_para~=1
    error('strand_model has not been processed yet!')
end
%%  default values
default_flag_plot = 1;      % 是否绘图
default_flag_G05  = 1;      % 是否使用G05指令
default_k         = 1;      % 修正系数
default_code_prefix = {...
    'G28;';...
    'G0 F3000;';...
    'G0 Z3.000;'...
    };                      % 前置代码
default_code_behind = {...
    'M107;';...
    'G91;';...
    'G0 F3000;';...
    'G0 Z2;';...
    'G90;';...
    'G00 X0 Y0;'...
    };                      % 后置代码
default_code_interl = {...
    };                      % 层间代码
%   声明一个p为inputParser格式的。其实也可以理解为一个该格式的句柄一样的东西
IP = inputParser;
addRequired(IP,'obj');
%   接下来两个是可选参数，名字分别为’stepsize'和'OptimalityTolerance'，如果没有检测到输入将有相应的缺省值defaulth和epsilon。这些都在函数开头声明好了
addParameter(IP,'flag_plot',default_flag_plot);
addParameter(IP,'flag_G05',default_flag_G05);
addParameter(IP,'k',default_k);
addParameter(IP,'code_prefix',default_code_prefix);
addParameter(IP,'code_behind',default_code_behind);
addParameter(IP,'code_interl',default_code_interl);
%   利用parse函数将输入参数与上面的进行匹配
parse(IP,obj,varargin{:});
%   此时就已经生成好了一个inputParser格式的参数p，p里面含有不少东西，其中它的Results为一个结构体，是输入参数在匹配后的值，利用这个可以完成我的output的赋值
flag_plot = IP.Results.flag_plot;
flag_G05  = IP.Results.flag_G05;
k         = IP.Results.k;
code_prefix=IP.Results.code_prefix;
code_behind=IP.Results.code_behind;
code_interl=IP.Results.code_interl;
%%  处理程序
% code_prefix = {...
%     'G28;';...
%     'G0 F3000;';...
%     'G0 Z3.000;'...
%     };
% code_behind = {...
%     'M107;';...
%     'G91;';...
%     'G0 F3000;';...
%     'G0 Z2;';...
%     'G90;';...
%     'G00 X0 Y0;'...
%     };
% code_interl = {...
%     };
draft_gcode=obj.PT_data.draft_gcode;
gcode_gen_g05(draft_gcode,code_prefix,code_behind,code_interl,'setpath',{obj.syset.path_outcod,'Gcode4PrintModified.gcode'});
% %%  结束与标记
% obj.syset.flags.flag_adjusted_para = 1;
end